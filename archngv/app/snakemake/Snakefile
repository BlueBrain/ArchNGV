import os
import yaml
import datetime
import logging

LOGS_DIR = 'logs'
MORPH_DIR = 'morphologies'
BIONAME = os.path.realpath(config.get('bioname', 'bioname'))


def _get_seed(manifest_path):
    """Get the seed from the manifest"""
    try:
        with open(manifest_path, 'r') as stream:
            manifest = yaml.safe_load(stream)
            return str(manifest['common']['seed'])
    except KeyError:
        return "0"


def bioname_path(filename):
    return os.path.join(BIONAME, filename)

MANIFEST = bioname_path('MANIFEST.yaml')
SEED = _get_seed(MANIFEST)

def log_path(name):
    timestamp = datetime.datetime.now().strftime("%Y%m%dT%H%M%S")
    return os.path.abspath(os.path.join(LOGS_DIR, "%s.%s.log" % (name, timestamp)))


def escape_single_quotes(value):
    return value.replace("'", "'\\''")


def get_log_level_for_cli(level):
    levels = (logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG)
    level = logging.getLevelName(level)
    assert level in levels, f'Unknown log level {level}. Allowed levels: {levels}'
    idx = levels.index(level)
    cli_level = ''.join(['v'] * idx)
    if cli_level:
        return f'-{cli_level}'
    return ''


# Load MANIFEST.yaml into workflow config
workflow.configfile(MANIFEST)


ATLAS = config['common']['atlas']
ATLAS_CACHE_DIR = ".atlas"
VASCULATURE_MORPHOLOGY = config['common']['vasculature']
PARALLEL = config['common'].get('parallel', True)
LOG_LEVEL = get_log_level_for_cli(config['common'].get('log_level', 'WARNING'))

BASE_CIRCUIT_SONATA = config['common']['base_circuit_sonata']
BASE_CIRCUIT_CELLS = config['common']['base_circuit_cells']
BASE_CIRCUIT_CONNECTOME = config['common']['base_circuit_connectome']
BUILDER_RECIPE = bioname_path('astrocyte_gap_junction_recipe.xml')

SPACK_MODULEPATH = "/gpfs/bbp.cscs.ch/ssd/apps/hpc/jenkins/modules/all"

MODULES = {
    'glial_gap_junctions':
        (SPACK_MODULEPATH, ['archive/2021-05', 'touchdetector']),
    'synthesis':
        (SPACK_MODULEPATH, ['archive/2021-05', 'py-mpi4py']),
}


TOUCHES_DIR = 'connectome/touches'


def propagate_cluster_default_values():
    # propagate the missing options from the default
    slurm_envs = set(cluster_config.keys()) - {'__default__'}
    default = cluster_config['__default__']
    for slurm_env in slurm_envs:
        slurm_dict = cluster_config[slurm_env]
        missing_keys = set(default.keys()) -  set(slurm_dict.keys())
        slurm_dict.update({key: default[key] for key in missing_keys})


def salloc_cmd(slurm_env):
    if (slurm_env is not None) and cluster_config:
        if slurm_env not in cluster_config:
            slurm_env = '__default__'

        cfg = cluster_config[slurm_env]
        options = (f"-C {cfg['constraint']} -A {cfg['account']} -N {cfg['nodes']}" +
                   f" -p {cfg['partition']} -J {cfg['jobname']} -t {cfg['time']}")
        if 'tasks' in cfg:
            options += f' -n {cfg["tasks"]}'
        if 'cpus-per-task' in cfg:
            options += f' --cpus-per-task {cfg["cpus-per-task"]}'
        if 'exclusive' in cfg:
            options += ' --exclusive'
        if 'mem' in cfg:
            options += f' --mem {cfg["mem"]}'
        return f'salloc {options}'
    return ""


def modules_cmd(module_env):
    if module_env is not None:
        modulepath, modules = MODULES[module_env]
        return " && ".join([
            "export MODULEPATH=%s" % modulepath,
            ". /etc/profile.d/modules.sh",
            "module purge",
            "module load %s" % " ".join(modules),
            "echo MODULEPATH=%s" % modulepath,
            "module list", " "
            ])
    return ""


def run_cmd(cmd, dump_log=False, module_env=None, slurm_env=None):
    """
    Args:
        cmd (array): shell command to run with its arguments
        dump_log (bool): whether to produce a log file
        module_env (str): modules specified for this command in MODULES
        slurm_env (str): slurm environment specified in cluster config
    """
    module = modules_cmd(module_env)
    salloc = salloc_cmd(slurm_env)
    command = ' '.join(map(str, cmd))
    result = f'{module} {salloc} {command}'

    if dump_log:
        result += " 2>&1 | tee {log}"
    return result


propagate_cluster_default_values()  #  cluster info propagation does not work so doing it here


rule all:
    input:
        'microdomains/overlapping_microdomains.h5',
        'endfeet_areas.h5',
        MORPH_DIR + '/_DONE',
        TOUCHES_DIR + '/_SUCCESS',
        'ngv_config.json',
        'sonata/nodes/glia.h5',
        'sonata/nodes/vasculature.h5',
        'sonata/edges/neuroglial.h5',
        'sonata/edges/glialglial.h5',
        'sonata/edges/gliovascular.h5',


rule sonata:
    input:
        'sonata/nodes/glia.h5',
        'sonata/edges/neuroglial.h5',


rule ngv_config:
    output:
        'ngv_config.json'

    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} config-file',
            '--bioname', BIONAME,
            '--output', '{output}',
        ])


rule sonata_vasculature:
    input:
        VASCULATURE_MORPHOLOGY

    output:
        'sonata/nodes/vasculature.h5'

    log:
        log_path('sonata_vasculature')

    shell:
        run_cmd([
            f'vasculatureapi morphology-to-sonata',
            '{input} {output}'],
            dump_log=True)


rule cell_placement:
    input:
        'sonata/nodes/vasculature.h5'

    output:
        'sonata.tmp/nodes/glia.somata.h5'

    log:
        log_path('cell_placement')

    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} cell-placement',
            f'--config {bioname_path("cell_placement.yaml")}',
            f'--atlas {ATLAS}',
            f'--atlas-cache {ATLAS_CACHE_DIR}',
            f'--vasculature {input}',
            '--output {output}',
            f'--seed {SEED}'],
            dump_log=True)


rule assign_emodels:
    input:
        'sonata.tmp/nodes/glia.somata.h5'

    output:
        'sonata.tmp/nodes/glia.emodels.h5'

    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} assign-emodels',
            '--input {input}',
            '--output {output}',
            f'--hoc {config["assign_emodels"]["hoc_template"]}',
        ])


rule finalize_astrocytes:
    input:
        somata = 'sonata.tmp/nodes/glia.somata.h5',
        emodels = 'sonata.tmp/nodes/glia.emodels.h5'

    output:
        'sonata/nodes/glia.h5'

    log:
        log_path('finalize_astrocytes')

    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} finalize-astrocytes',
            '--somata-file {input[somata]}',
            '--emodels-file {input[emodels]}',
            '--output {output}'],
            dump_log=True)


rule microdomains:
    input:
        'sonata/nodes/glia.h5'

    output:
        'microdomains/microdomains.h5',
        'microdomains/overlapping_microdomains.h5',

    log:
        log_path('microdomains')

    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} microdomains',
            f'--config {bioname_path("microdomains.yaml")}',
            '--astrocytes {input}',
            f'--atlas {ATLAS}',
            f'--atlas-cache {ATLAS_CACHE_DIR}',
            '--output-dir microdomains',
            f'--seed {SEED}'],
            dump_log=True)


rule gliovascular_connectivity:
    input:
        astrocytes = 'sonata/nodes/glia.h5',
        microdomains = 'microdomains/overlapping_microdomains.h5',
        vasculature = 'sonata/nodes/vasculature.h5'

    output:
        'sonata.tmp/edges/gliovascular.connectivity.h5',

    log:
        log_path('gliovascular_connectivity')

    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} gliovascular connectivity',
            f'--config {bioname_path("gliovascular_connectivity.yaml")}',
            '--astrocytes {input[astrocytes]}',
            '--microdomains {input[microdomains]}',
            '--vasculature {input[vasculature]}',
            f'--seed {SEED}',
            '--output {output}'],
            dump_log=True)


rule neuroglial_connectivity:
    input:
        astrocytes = 'sonata/nodes/glia.h5',
        microdomains = 'microdomains/overlapping_microdomains.h5',

    output:
        'sonata.tmp/edges/neuroglial.connectivity.h5',

    log:
        log_path('neuroglial_connectivity')

    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} neuroglial connectivity',
            f'--neurons {BASE_CIRCUIT_CELLS}',
            '--astrocytes {input[astrocytes]}',
            '--microdomains {input[microdomains]}',
            f'--neuronal-connectivity {BASE_CIRCUIT_CONNECTOME}',
            '--output {output}',
            f'--seed {SEED}'],
            dump_log=True)

rule glial_gap_junctions:
    message:
        "Detect touches between astrocytes"

    input:
        astrocytes = 'sonata/nodes/glia.h5',
        morphologies = MORPH_DIR + '/_DONE'

    output:
        touch(TOUCHES_DIR + '/_SUCCESS')

    log:
        log_path('touchdetector')

    shell:
        run_cmd([
            'srun --mpi pmi2 sh -c "' +
            ' '.join(['touchdetector',
            f'--output {TOUCHES_DIR}',
            '--save-state',
            '--from {input[astrocytes]} astrocytes',
            '--to {input[astrocytes]} astrocytes',
            BUILDER_RECIPE,
            MORPH_DIR]) + '"'],
            dump_log=True,
            module_env='glial_gap_junctions',
            slurm_env='glial_gap_junctions'
        )


rule glialglial_connectivity:
    message:
        " Extract glial glial connectivity from touches"

    input:
        astrocytes = 'sonata/nodes/glia.h5',
        touches = TOUCHES_DIR + '/_SUCCESS'

    output:
        glialglial_connectivity = 'sonata/edges/glialglial.h5'

    log:
        log_path('glialglial_connectivity')

    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} glialglial-connectivity',
            '--astrocytes {input[astrocytes]}',
            f'--touches-dir {TOUCHES_DIR}',
            '--output-connectivity {output[glialglial_connectivity]}',
            f'--seed {SEED}'],
            dump_log=True,
        )


rule endfeet_area:
    input:
        gliovascular_connectivity = 'sonata.tmp/edges/gliovascular.connectivity.h5',

    output:
        'endfeet_areas.h5'

    log:
        log_path('endfeet_area')

    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} endfeet-area',
            f'--config {bioname_path("endfeet_area.yaml")}',
            f'--vasculature-mesh {config["common"]["vasculature_mesh"]}',
            '--gliovascular-connectivity {input[gliovascular_connectivity]}',
            '--output {output}',
            f'--seed {SEED}'],
            dump_log=True)


rule synthesis:
    input:
        astrocytes = 'sonata/nodes/glia.h5',
        microdomains = 'microdomains/overlapping_microdomains.h5',
        gliovascular_connectivity = 'sonata.tmp/edges/gliovascular.connectivity.h5',
        neuroglial_connectivity = 'sonata.tmp/edges/neuroglial.connectivity.h5',
        endfeet_areas = 'endfeet_areas.h5'

    output:
        touch(MORPH_DIR + '/_DONE'),

    log:
        log_path('synthesis')

    shell:
        run_cmd([
            'srun' if PARALLEL else '',
            f'ngv {LOG_LEVEL} synthesis',
            f'--config {bioname_path("synthesis.yaml")}',
            f'--tns-distributions {bioname_path("tns_distributions.json")}',
            f'--tns-parameters {bioname_path("tns_parameters.json")}',
            f'--tns-context {bioname_path("tns_context.json")}',
            f'--er-data {bioname_path("er_data.json")}',
            '--astrocytes {input[astrocytes]}',
            '--microdomains {input[microdomains]}',
            '--gliovascular-connectivity {input[gliovascular_connectivity]}',
            '--neuroglial-connectivity {input[neuroglial_connectivity]}',
            '--endfeet-areas {input[endfeet_areas]}',
            f'--neuronal-connectivity {BASE_CIRCUIT_CONNECTOME}',
            f'--out-morph-dir {MORPH_DIR}',
            ('--parallel' if PARALLEL else ''),
            f'--seed {SEED}'],
            dump_log=True,
            module_env='synthesis' if PARALLEL else None,
            slurm_env='synthesis' if PARALLEL else None,
        )


rule finalize_gliovascular_connectivity:
    input:
        astrocytes = 'sonata/nodes/glia.h5',
        connectivity = 'sonata.tmp/edges/gliovascular.connectivity.h5',
        endfeet_areas = 'endfeet_areas.h5',
        morphologies = MORPH_DIR + '/_DONE',
        vasculature_sonata = 'sonata/nodes/vasculature.h5'

    output:
        'sonata/edges/gliovascular.h5'
    log:
        log_path('finalize_gliovascular_connectivity')
    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} gliovascular finalize',
            '--input-file {input[connectivity]}',
            '--output-file {output}',
            '--astrocytes {input[astrocytes]}',
            '--endfeet-areas {input[endfeet_areas]}',
            '--vasculature-sonata {input[vasculature_sonata]}',
            f'--morph-dir {MORPH_DIR}',
            ('--parallel' if PARALLEL else ''),
            f'--seed {SEED}'],
            dump_log=True
        )


rule finalize_neuroglial_connectivity:
    input:
        astrocytes = 'sonata/nodes/glia.h5',
        microdomains = 'microdomains/overlapping_microdomains.h5',
        connectivity = 'sonata.tmp/edges/neuroglial.connectivity.h5',
        morphologies = MORPH_DIR + '/_DONE',

    output:
        'sonata/edges/neuroglial.h5'

    log:
        log_path('finalize_neuroglial_connectivity')

    shell:
        run_cmd([
            f'ngv {LOG_LEVEL} neuroglial finalize',
            '--input-file {input[connectivity]}',
            '--output-file {output}',
            '--astrocytes {input[astrocytes]}',
            '--microdomains {input[microdomains]}',
            f'--synaptic-data {BASE_CIRCUIT_CONNECTOME}',
            f'--morph-dir {MORPH_DIR}',
            ('--parallel' if PARALLEL else ''),
            f'--seed {SEED}'],
            dump_log=True)
